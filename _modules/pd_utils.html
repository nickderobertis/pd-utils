

<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pd_utils &mdash; pd_utils 0.1.1 documentation</title>
  

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
        <script type="text/javascript">var copybuttonSkipText = '>>> ';</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> pd_utils
          

          
          </a>

          
            
            
              <div class="version">
                0.1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Getting started with pd_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">This is my gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/modules.html">pd_utils</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pd_utils</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>pd_utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pd_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">High-level tools for common Pandas workflows</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span> <span class="k">as</span> <span class="n">ThreadPool</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">dateutil.relativedelta</span> <span class="kn">import</span> <span class="n">relativedelta</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">nan</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.holiday</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AbstractHolidayCalendar</span><span class="p">,</span>
    <span class="n">GoodFriday</span><span class="p">,</span>
    <span class="n">Holiday</span><span class="p">,</span>
    <span class="n">USLaborDay</span><span class="p">,</span>
    <span class="n">USMartinLutherKingJr</span><span class="p">,</span>
    <span class="n">USMemorialDay</span><span class="p">,</span>
    <span class="n">USPresidentsDay</span><span class="p">,</span>
    <span class="n">USThanksgivingDay</span><span class="p">,</span>
    <span class="n">nearest_workday</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.offsets</span> <span class="kn">import</span> <span class="n">CustomBusinessDay</span>
<span class="kn">from</span> <span class="nn">pandasql</span> <span class="kn">import</span> <span class="n">PandaSQL</span>
<span class="kn">from</span> <span class="nn">sas7bdat</span> <span class="kn">import</span> <span class="n">SAS7BDAT</span>

<span class="kn">from</span> <span class="nn">pd_utils.timer</span> <span class="kn">import</span> <span class="n">estimate_time</span>

<span class="kn">from</span> <span class="nn">.filldata</span> <span class="kn">import</span> <span class="n">fillna_by_groups</span><span class="p">,</span> <span class="n">fillna_by_groups_and_keep_one_per_group</span>
<span class="kn">from</span> <span class="nn">.pdutils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_assert_byvars_list</span><span class="p">,</span>
    <span class="n">_check_portfolio_inputs</span><span class="p">,</span>
    <span class="n">_create_cutoffs_and_sort_into_ports</span><span class="p">,</span>
    <span class="n">_expand</span><span class="p">,</span>
    <span class="n">_extract_table_names_from_sql</span><span class="p">,</span>
    <span class="n">_get_datetime_cols</span><span class="p">,</span>
    <span class="n">_portfolio_difference</span><span class="p">,</span>
    <span class="n">_select_long_short_ports</span><span class="p">,</span>
    <span class="n">_sort_arr_list_into_ports_and_return_series</span><span class="p">,</span>
    <span class="n">_sort_into_ports</span><span class="p">,</span>
    <span class="n">_split</span><span class="p">,</span>
    <span class="n">_to_list_if_str</span><span class="p">,</span>
    <span class="n">_to_name_if_series</span><span class="p">,</span>
    <span class="n">_to_series_if_str</span><span class="p">,</span>
    <span class="n">split</span><span class="p">,</span>
    <span class="n">window_mapping</span><span class="p">,</span>
    <span class="n">year_month_from_single_date</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.regby</span> <span class="kn">import</span> <span class="n">reg_by</span>
<span class="kn">from</span> <span class="nn">pd_utils.corr</span> <span class="kn">import</span> <span class="n">formatted_corr_df</span>


<div class="viewcode-block" id="to_csv"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.to_csv">[docs]</a><span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    action=&#39;w&#39; for overwrite, &#39;a&#39; for append</span>
<span class="sd">    set index to False to not include index in output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">dataframe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if dataframe exists</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now saving </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">dataframe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># could use easier dataframe.to_csv(filepath) syntax, but won&#39;t overwrite</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="n">dataframe</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\ufffd</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> does not exist.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dataframe</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># does nothing if dataframe doesn&#39;t exist</span></div>


<div class="viewcode-block" id="convert_sas_date_to_pandas_date"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.convert_sas_date_to_pandas_date">[docs]</a><span class="k">def</span> <span class="nf">convert_sas_date_to_pandas_date</span><span class="p">(</span><span class="n">sasdates</span><span class="p">):</span>
    <span class="n">epoch</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1960</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="n">date</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">date</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">NaT</span>
        <span class="k">return</span> <span class="n">epoch</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">date</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sasdates</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="c1"># Below code is to reduce down to unique dates and create a mapping</span>

        <span class="c1">#         unique = pd.Series(sasdates.dropna().unique()).astype(int)</span>
        <span class="c1">#         shift = unique.apply(datetime.timedelta)</span>
        <span class="c1">#         pd_dates = epoch + shift</span>

        <span class="c1">#         for_merge = pd.concat([unique, pd_dates], axis=1)</span>
        <span class="c1">#         for_merge.columns = [sasdates.name, 0]</span>

        <span class="c1">#         orig_df = pd.DataFrame(sasdates)</span>
        <span class="c1">#         orig_df.reset_index(inplace=True)</span>

        <span class="c1">#         return for_merge.merge(orig_df, how=&#39;right&#39;, on=[sasdates.name]).sort_values(&#39;index&#39;).reset_index()[0]</span>

        <span class="k">return</span> <span class="n">apply_func_to_unique_and_merge</span><span class="p">(</span><span class="n">sasdates</span><span class="p">,</span> <span class="n">to_pandas</span><span class="p">)</span>

    <span class="c1">#         return pd.Series([epoch + datetime.timedelta(days=int(float(date))) if not pd.isnull(date) else nan for date in sasdates])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">to_pandas</span><span class="p">(</span><span class="n">sasdates</span><span class="p">)</span></div>


<div class="viewcode-block" id="year_month_from_date"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.year_month_from_date">[docs]</a><span class="k">def</span> <span class="nf">year_month_from_date</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">date</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">yearname</span><span class="o">=</span><span class="s2">&quot;Year&quot;</span><span class="p">,</span> <span class="n">monthname</span><span class="o">=</span><span class="s2">&quot;Month&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dataframe with a datetime object and creates year and month variables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1">#     df[yearname] =  [date.year  for date in df[date]]</span>
    <span class="c1">#     df[monthname] = [date.month for date in df[date]]</span>
    <span class="c1">#     df[[yearname, monthname]] = apply_func_to_unique_and_merge(df[date], year_month_from_single_date)</span>
    <span class="c1">### TEMP</span>
    <span class="n">df</span><span class="p">[</span><span class="n">yearname</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">monthname</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">date</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">month</span><span class="p">)</span>
    <span class="c1">### END TEMP</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="expand_time"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.expand_time">[docs]</a><span class="k">def</span> <span class="nf">expand_time</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">intermediate_periods</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates new observations in the dataset advancing the time by the int or list given. Creates a new date variable.</span>
<span class="sd">    See _expand_time for keyword arguments.</span>

<span class="sd">    Specify intermediate_periods=True to get periods in between given time periods, e.g.</span>
<span class="sd">    passing time=[12,24,36] will get periods 12, 13, 14, ..., 35, 36.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">intermediate_periods</span><span class="p">:</span>
        <span class="k">assert</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>
    <span class="k">return</span> <span class="n">_expand_time</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_expand_time</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
    <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span>
    <span class="n">time</span><span class="o">=</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span>
    <span class="n">newdate</span><span class="o">=</span><span class="s2">&quot;Shift Date&quot;</span><span class="p">,</span>
    <span class="n">shiftvar</span><span class="o">=</span><span class="s2">&quot;Shift&quot;</span><span class="p">,</span>
    <span class="n">custom_business_day</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CustomBusinessDay</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates new observations in the dataset advancing the time by the int or list given. Creates a new date variable.</span>

<span class="sd">    custom_business_day: pandas.tseries.offsets.CustomBusinessDay. Only used for daily frequency. Defaults to using</span>
<span class="sd">    trading days based on US market holiday calendar. Can pass custom business days for other calendars</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">message</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Initializing expand_time for periods </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">custom_business_day</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Daily frequency, getting trading day calendar.&quot;</span><span class="p">)</span>
            <span class="n">td</span> <span class="o">=</span> <span class="n">tradedays</span><span class="p">()</span>  <span class="c1"># gets trading day calendar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Daily frequency, using passed business day calendar.&quot;</span><span class="p">)</span>
            <span class="n">td</span> <span class="o">=</span> <span class="n">custom_business_day</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">td</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">time_shift</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="n">td</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">months</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">shift</span> <span class="o">*</span> <span class="n">td</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">years</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">time</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating number of rows.&quot;</span><span class="p">)</span>
    <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Calculating number of duplicates.&quot;</span><span class="p">)</span>
    <span class="n">duplicates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="c1"># Expand number of rows</span>
    <span class="k">if</span> <span class="n">duplicates</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Duplicating observations </span><span class="si">{}</span><span class="s2"> times.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">duplicates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">df</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">duplicates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Duplicated.&quot;</span><span class="p">)</span>

    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Creating shift variable.&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">shiftvar</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">time</span> <span class="o">*</span> <span class="n">num_rows</span>
    <span class="p">)</span>  <span class="c1"># Create a variable containing amount of time to shift</span>
    <span class="c1"># Now create shifted date</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Creating shifted date.&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="n">newdate</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">date</span> <span class="o">+</span> <span class="n">time_shift</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span> <span class="k">for</span> <span class="n">date</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">datevar</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">shiftvar</span><span class="p">])</span>
    <span class="p">]</span>
    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;expand_time completed.&quot;</span><span class="p">)</span>

    <span class="c1"># Cleanup and exit</span>
    <span class="k">return</span> <span class="n">df</span>  <span class="c1"># .drop(&#39;Shift&#39;, axis=1)</span>


<div class="viewcode-block" id="expand_months"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.expand_months">[docs]</a><span class="k">def</span> <span class="nf">expand_months</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">newdatevar</span><span class="o">=</span><span class="s2">&quot;Daily Date&quot;</span><span class="p">,</span> <span class="n">trade_days</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a monthly dataframe and returns a daily (trade day or calendar day) dataframe.</span>
<span class="sd">    For each row in the input data, duplicates that row over each trading/calendar day in the month of</span>
<span class="sd">    the date in that row. Creates a new date column containing the daily date.</span>

<span class="sd">    NOTE: If the input dataset has multiple observations per month, all of these will be expanded. Therefore</span>
<span class="sd">    you will have one row for each trade day for each original observation.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas dataframe containing a date variable</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    datevar: str, name of column containing dates in the input df</span>
<span class="sd">    newdatevar: str, name of new column to be created containing daily dates</span>
<span class="sd">    tradedays: bool, True to use trading days and False to use calendar days</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trade_days</span><span class="p">:</span>
        <span class="n">td</span> <span class="o">=</span> <span class="n">tradedays</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">td</span> <span class="o">=</span> <span class="s2">&quot;D&quot;</span>

    <span class="n">expand</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_expand</span><span class="p">,</span> <span class="n">datevar</span><span class="o">=</span><span class="n">datevar</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="n">td</span><span class="p">,</span> <span class="n">newdatevar</span><span class="o">=</span><span class="n">newdatevar</span><span class="p">)</span>

    <span class="n">expand_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">expand</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span>

    <span class="n">days</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">expand_all</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">datevar</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">datevar</span><span class="p">,</span> <span class="n">newdatevar</span><span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;datetime64&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">datevar</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="cumulate"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.cumulate">[docs]</a><span class="k">def</span> <span class="nf">cumulate</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">cumvars</span><span class="p">,</span>
    <span class="n">method</span><span class="p">,</span>
    <span class="n">periodvar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
    <span class="n">byvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">grossify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">multiprocess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cumulates a variable over time. Typically used to get cumulative returns.</span>

<span class="sd">    NOTE: Method zero not yet working</span>

<span class="sd">    method = &#39;between&#39;, &#39;zero&#39;, or &#39;first&#39;.</span>
<span class="sd">             If &#39;zero&#39;, will give returns since the original date. Note: for periods before the original date,</span>
<span class="sd">             this will turn positive returns negative as we are going backwards in time.</span>
<span class="sd">             If &#39;between&#39;, will give returns since the prior requested time period. Note that</span>
<span class="sd">             the first period is period 0.</span>
<span class="sd">             If &#39;first&#39;, will give returns since the first requested time period.</span>
<span class="sd">             For example, if our input data was for date 1/5/2006, but we had shifted dates:</span>
<span class="sd">                 permno  date      RET  shift_date</span>
<span class="sd">                 10516   1/5/2006  110%  1/5/2006</span>
<span class="sd">                 10516   1/5/2006  120%  1/6/2006</span>
<span class="sd">                 10516   1/5/2006  105%  1/7/2006</span>
<span class="sd">                 10516   1/5/2006  130%  1/8/2006</span>
<span class="sd">             Then cumulate(df, &#39;RET&#39;, cumret=&#39;between&#39;, time=[1,3], get=&#39;RET&#39;, periodvar=&#39;shift_date&#39;) would return:</span>
<span class="sd">                 permno  date      RET  shift_date  cumret</span>
<span class="sd">                 10516   1/5/2006  110%  1/5/2006    110%</span>
<span class="sd">                 10516   1/5/2006  120%  1/6/2006    120%</span>
<span class="sd">                 10516   1/5/2006  105%  1/7/2006    126%</span>
<span class="sd">                 10516   1/5/2006  130%  1/8/2006    130%</span>
<span class="sd">             Then cumulate(df, &#39;RET&#39;, cumret=&#39;first&#39;, periodvar=&#39;shift_date&#39;) would return:</span>
<span class="sd">                 permno  date      RET  shift_date  cumret</span>
<span class="sd">                 10516   1/5/2006  110%  1/5/2006    110%</span>
<span class="sd">                 10516   1/5/2006  120%  1/6/2006    120%</span>
<span class="sd">                 10516   1/5/2006  105%  1/7/2006    126%</span>
<span class="sd">                 10516   1/5/2006  130%  1/8/2006    163.8%</span>
<span class="sd">    byvars: string or list of column names to use to seperate by groups</span>
<span class="sd">    time: list of ints, for use with method=&#39;between&#39;. Defines which periods to calculate between.</span>
<span class="sd">    grossify: bool, set to True to add one to all variables then subtract one at the end</span>
<span class="sd">    multiprocess: bool or int, set to True to use all available processors,</span>
<span class="sd">                  set to False to use only one, pass an int less or equal to than number of</span>
<span class="sd">                  processors to use that amount of processors</span>
<span class="sd">    replace: bool, True to return df with passed columns replaced with cumulated columns.</span>
<span class="sd">             False to return df with both passed columns and cumulated columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">time2</span>  <span class="c1"># accidentally used time an an input parameter and don&#39;t want to break prior code</span>

    <span class="c1"># TODO [#1]: get method &#39;zero&#39; of cumulate working</span>
    <span class="c1">#</span>
    <span class="c1"># Has some WIP already commited, commented out</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">message</span> <span class="o">!=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">message</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Initializing cumulate.&quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># don&#39;t want to modify original dataframe</span>

    <span class="n">sort_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">time</span><span class="p">:</span>
        <span class="n">sort_time</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sort_time</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cumvars</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">cumvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">cumvars</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cumvars</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grossify</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grossify</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cumvars</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># For method &#39;zero&#39; implementation</span>
    <span class="c1"># def unflip(df, cumvars):</span>
    <span class="c1">#     flipcols = [&#39;cum_&#39; + str(c) for c in cumvars] #select cumulated columns</span>
    <span class="c1">#     for col in flipcols:</span>
    <span class="c1">#         tempdf[col] = tempdf[col].shift(1) #shift all values down one row for cumvars</span>
    <span class="c1">#         tempdf[col] = -tempdf[col] + 2 #converts a positive return into a negative return</span>
    <span class="c1">#     tempdf = tempdf[1:].copy() #drop out period 0</span>
    <span class="c1">#     tempdf = tempdf.sort_values(periodvar) #resort to original order</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">flip</span><span class="p">):</span>
        <span class="n">flip_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">flip</span><span class="p">)]</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;window&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">flip</span><span class="p">)]</span>
        <span class="n">flip_df</span> <span class="o">=</span> <span class="n">flip_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">byvars</span> <span class="o">+</span> <span class="p">[</span><span class="n">periodvar</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">flip_df</span><span class="p">,</span> <span class="n">rest</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cumulate</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">mp</span><span class="o">=</span><span class="n">multiprocess</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">multiprocess</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">multiprocess</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_cumulate_mp</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">mp</span><span class="o">=</span><span class="n">mp</span><span class="p">)</span>  <span class="c1"># use mp # processors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_cumulate_mp</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>  <span class="c1"># use all processors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_cumulate_sp</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cumulate_sp</span><span class="p">(</span><span class="n">array_list</span><span class="p">):</span>
        <span class="n">out_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">array_list</span><span class="p">:</span>
            <span class="n">out_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">out_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cumulate_mp</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">mp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mp</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>  <span class="c1"># use mp # processors</span>
                <span class="k">return</span> <span class="n">_cumulate_mp_main</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>  <span class="c1"># use all processors</span>
                <span class="k">return</span> <span class="n">_cumulate_mp_main</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">pool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cumulate_mp_main</span><span class="p">(</span><span class="n">array_list</span><span class="p">,</span> <span class="n">pool</span><span class="p">):</span>

        <span class="c1"># For time estimation</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_loops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

        <span class="c1"># Mp setup</span>
        <span class="n">cum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">cum</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="p">,),</span> <span class="n">callback</span><span class="o">=</span><span class="n">counter</span><span class="o">.</span><span class="n">append</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">array_list</span>
        <span class="p">]</span>

        <span class="c1"># Time estimation</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_loops</span><span class="p">:</span>
            <span class="n">estimate_time</span><span class="p">(</span><span class="n">num_loops</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">counter</span><span class="p">),</span> <span class="n">start_time</span><span class="p">)</span>
            <span class="n">time2</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Collect and output results. A timeout of 1 should be fine because</span>
        <span class="c1"># it should wait until completion anyway</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#####TEMPORARY CODE######</span>
    <span class="k">assert</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;zero&quot;</span>
    <span class="c1">#########################</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">byvars</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;zero&quot;</span><span class="p">,</span> <span class="s2">&quot;between&quot;</span><span class="p">,</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># need time for between method</span>
    <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Time provided but method was not between. Time will be ignored.&quot;</span><span class="p">)</span>

    <span class="c1"># Creates a variable containing index of window in which the observation belongs</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;between&quot;</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_map_windows</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">sort_time</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">periodvar</span><span class="o">=</span><span class="n">periodvar</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="n">byvars</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__map_window__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">periodvar</span><span class="p">]</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">periodvar</span><span class="p">]),</span> <span class="s2">&quot;__map_window__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">####################TEMP</span>
    <span class="c1">#     import pdb</span>
    <span class="c1">#     pdb.set_trace()</span>
    <span class="c1">#######################</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">byvars</span><span class="p">:</span>
        <span class="n">byvars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;__map_window__&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">byvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;__map_window__&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="c1"># need to determine when to cumulate backwards</span>
    <span class="c1"># check if method is zero, there only negatives and zero, and there is at least one negative in each window</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;zero&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;need to implement method zero&quot;</span><span class="p">)</span>
        <span class="c1"># flip is a list of indices of windows for which the window should be flipped</span>
        <span class="c1"># to_flip = [j for j, window in enumerate(windows) \</span>
        <span class="c1">#        if all([i &lt;= 0 for i in window]) and any([i &lt; 0 for i in window])]</span>
        <span class="c1"># df = flip(df, to_flip)</span>

    <span class="n">log</span><span class="p">(</span><span class="s2">&quot;Creating by groups.&quot;</span><span class="p">)</span>

    <span class="c1"># Create by groups</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;__key_var__&quot;</span>  <span class="c1"># container for key</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">byvars</span><span class="p">]:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">col</span>

    <span class="n">array_list</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cumvars</span><span class="p">)</span>

    <span class="c1">#     container_array = df[cumvars].values</span>
    <span class="n">full_array</span> <span class="o">=</span> <span class="n">_cumulate</span><span class="p">(</span><span class="n">array_list</span><span class="p">)</span>

    <span class="n">new_cumvars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cum_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cumvars</span><span class="p">]</span>

    <span class="n">cumdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">full_array</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_cumvars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">outdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">cumdf</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span> <span class="o">==</span> <span class="s2">&quot;zero&quot;</span> <span class="ow">and</span> <span class="n">flip</span> <span class="o">!=</span> <span class="p">[]:</span>  <span class="c1"># if we flipped some of the dataframe</span>
        <span class="k">pass</span>  <span class="c1"># TEMPORARY</span>

    <span class="k">if</span> <span class="n">grossify</span><span class="p">:</span>
        <span class="n">all_cumvars</span> <span class="o">=</span> <span class="n">cumvars</span> <span class="o">+</span> <span class="n">new_cumvars</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">all_cumvars</span><span class="p">:</span>
            <span class="n">outdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">outdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
        <span class="n">outdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cumvars</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">outdf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;cum_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cumvar</span><span class="p">):</span> <span class="n">cumvar</span> <span class="k">for</span> <span class="n">cumvar</span> <span class="ow">in</span> <span class="n">cumvars</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="n">drop_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">outdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">outdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">drop_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="long_to_wide"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.long_to_wide">[docs]</a><span class="k">def</span> <span class="nf">long_to_wide</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">groupvars</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">colindex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colindex_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    groupvars = string or list of variables which signify unique observations in the output dataset</span>
<span class="sd">    values = string or list of variables which contain the values which need to be transposed</span>
<span class="sd">    colindex = string of column or list of strings of columns containing extension for column name</span>
<span class="sd">               in the output dataset. If not specified, just uses the</span>
<span class="sd">               count of the row within the group. If a list is provided, each column value will be appended</span>
<span class="sd">               in order separated by _</span>
<span class="sd">    colindex_only = boolean. If true, column names in output data will be only the colindex, and will not</span>
<span class="sd">                    include the name of the values variable. Only valid when passing a single value, otherwise</span>
<span class="sd">                    multiple columns would have the same name.</span>


<span class="sd">    NOTE: Don&#39;t have any variables named key or idx</span>

<span class="sd">    For example, if we had a long dataset of returns, with returns 12, 24, 36, 48, and 60 months after the date:</span>
<span class="sd">            ticker    ret    months</span>
<span class="sd">            AA        .01    12</span>
<span class="sd">            AA        .15    24</span>
<span class="sd">            AA        .21    36</span>
<span class="sd">            AA       -.10    48</span>
<span class="sd">            AA        .22    60</span>
<span class="sd">    and we want to get this to one observation per ticker:</span>
<span class="sd">            ticker    ret12    ret24    ret36    ret48    ret60</span>
<span class="sd">            AA        .01      .15      .21     -.10      .22</span>
<span class="sd">    We would use:</span>
<span class="sd">    long_to_wide(df, groupvars=&#39;ticker&#39;, values=&#39;ret&#39;, colindex=&#39;months&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># don&#39;t overwrite original</span>

    <span class="c1"># Check for duplicates</span>
    <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Found duplicate rows and deleted.&quot;</span><span class="p">)</span>

    <span class="c1"># Ensure type of groupvars is correct</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">groupvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">groupvars</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupvars</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="c1"># Ensure type of values is correct</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">colindex_only</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;set colindex_only to False when passing more than one value&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Fixes for colindex</span>
    <span class="c1"># Use count of the row within the group for column index if not specified</span>
    <span class="k">if</span> <span class="n">colindex</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__idx__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupvars</span><span class="p">)</span><span class="o">.</span><span class="n">cumcount</span><span class="p">()</span>
        <span class="n">colindex</span> <span class="o">=</span> <span class="s2">&quot;__idx__&quot;</span>
    <span class="c1"># If multiple columns are provided for colindex, combine and drop old cols</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colindex</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__idx__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">colindex</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__idx__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__idx__&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">colindex</span> <span class="o">=</span> <span class="s2">&quot;__idx__&quot;</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__key__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">groupvars</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># create key variable</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groupvars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if there are multiple groupvars, combine into one key</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">groupvars</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__key__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__key__&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Create seperate wide datasets for each value variable then merge them together</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Create wide dataset</span>
        <span class="n">raw_wide</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;__key__&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">colindex</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">colindex_only</span><span class="p">:</span>
            <span class="c1"># add value name</span>
            <span class="n">raw_wide</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">raw_wide</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove _ from colindex name</span>
            <span class="n">raw_wide</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">raw_wide</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">wide</span> <span class="o">=</span> <span class="n">raw_wide</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Merge back to original dataset</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">wide</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;__key__&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">colindex</span><span class="p">,</span> <span class="s2">&quot;__key__&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="load_sas"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.load_sas">[docs]</a><span class="k">def</span> <span class="nf">load_sas</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">csv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">read_csv_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads sas sas7bdat file into a pandas DataFrame.</span>

<span class="sd">    :param filepath: str of location of sas7bdat file</span>
<span class="sd">    :param csv: when set to True, saves a csv version of the data in the same directory as the sas7bdat.</span>
<span class="sd">                Next time load_sas will load from the csv version rather than sas7bdat, which speeds up</span>
<span class="sd">                load times about 3x. If the sas7bdat file is modified more recently than the csv,</span>
<span class="sd">                the sas7bdat will automatically be loaded and saved to the csv again.</span>
<span class="sd">    :param read_csv_kwargs: kwargs to pass to pd.read_csv if csv option is True</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sas_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>  <span class="c1"># e.g. dsename.sas7bdat</span>
    <span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>  <span class="c1"># location of sas file</span>
    <span class="n">filename</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">sas_name</span><span class="p">)</span>  <span class="c1"># returns (&#39;dsenames&#39;,&#39;.sas7bdat&#39;)</span>
    <span class="n">csv_name</span> <span class="o">=</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span>
    <span class="n">csv_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">csv_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">csv_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">csv</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span><span class="n">csv_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getmtime</span><span class="p">(</span>
            <span class="n">filepath</span>
        <span class="p">):</span>  <span class="c1"># if csv was modified more recently</span>
            <span class="c1"># Read from csv (don&#39;t touch sas7bdat because slower loading)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">read_csv_kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">UnicodeDecodeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;cp1252&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">read_csv_kwargs</span><span class="p">)</span>

    <span class="c1"># In the case that there is no csv already, or that the sas7bdat has been modified more recently</span>
    <span class="c1"># Pull from SAS file</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">SAS7BDAT</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span><span class="o">.</span><span class="n">to_data_frame</span><span class="p">()</span>
    <span class="c1"># Write to csv file</span>
    <span class="k">if</span> <span class="n">csv</span><span class="p">:</span>
        <span class="n">to_csv</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="averages"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.averages">[docs]</a><span class="k">def</span> <span class="nf">averages</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">avgvars</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">wtvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns equal- and value-weighted averages of variables within groups</span>

<span class="sd">    avgvars: List of strings or string of variable names to take averages of</span>
<span class="sd">    byvars: List of strings or string of variable names for by groups</span>
<span class="sd">    wtvar: String of variable to use for calculating weights in weighted average</span>
<span class="sd">    count: False or string of variable name, pass variable name to get count of non-missing</span>
<span class="sd">           of that variable within groups.</span>
<span class="sd">    flatten: Boolean, False to return df with multi-level index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check types</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avgvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">avgvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">avgvars</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avgvars</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="n">avgvars</span> <span class="o">=</span> <span class="n">avgvars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># don&#39;t modify existing avgvars inplace</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">wtvar</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wtvar</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">groupby_merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
        <span class="n">avgvars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">count</span> <span class="o">+</span> <span class="s2">&quot;_count&quot;</span><span class="p">]</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">byvars</span><span class="p">)</span>
    <span class="n">avg_df</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="n">avgvars</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">wtvar</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg_df</span>

    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">avgvars</span><span class="p">:</span>
        <span class="n">colname</span> <span class="o">=</span> <span class="n">var</span> <span class="o">+</span> <span class="s2">&quot;_wavg&quot;</span>
        <span class="n">df</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">wtvar</span><span class="p">]</span> <span class="o">/</span> <span class="n">g</span><span class="p">[</span><span class="n">wtvar</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>

    <span class="n">wavg_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;wavg&quot;</span><span class="p">]</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">byvars</span><span class="p">)</span>  <span class="c1"># recreate because we not have _wavg cols in df</span>
    <span class="n">wavg_df</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">sum</span><span class="p">()[</span><span class="n">wavg_cols</span><span class="p">]</span>

    <span class="n">outdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">avg_df</span><span class="p">,</span> <span class="n">wavg_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outdf</span></div>


<div class="viewcode-block" id="portfolio"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.portfolio">[docs]</a><span class="k">def</span> <span class="nf">portfolio</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">groupvar</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">cutoffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">quant_cutoffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">byvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cutdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">portvar</span><span class="o">=</span><span class="s2">&quot;portfolio&quot;</span><span class="p">,</span>
    <span class="n">multiprocess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs portfolios based on percentile values of groupvar. If ngroups=10, then will form 10 portfolios,</span>
<span class="sd">    with portfolio 1 having the bottom 10 percentile of groupvar, and portfolio 10 having the top 10 percentile</span>
<span class="sd">    of groupvar.</span>

<span class="sd">    df: pandas dataframe, input data</span>
<span class="sd">    groupvar: string, name of variable in df to form portfolios on</span>
<span class="sd">    ngroups: integer, number of portfolios to form. will be ignored if option cutoffs or quant_cutoffs is passed</span>
<span class="sd">    cutoffs: e.g. [100, 10000] to form three portfolios, 1 would be &lt; 100, 2 would be &gt; 100 and &lt; 10000,</span>
<span class="sd">        3 would be &gt; 10000. cannot be used with option ngroups</span>
<span class="sd">    quant_cutoffs: eg. [0.1, 0.9] to form three portfolios. 1 would be lowest 10% of data,</span>
<span class="sd">        2 would be &gt; 10 and &lt; 90 percentiles, 3 would be highest 10%. All will be within byvars if byvars are passed.</span>
<span class="sd">    byvars: string, list, or None, name of variable(s) in df, finds portfolios within byvars. For example if byvars=&#39;Month&#39;,</span>
<span class="sd">            would take each month and form portfolios based on the percentiles of the groupvar during only that month</span>
<span class="sd">    cutdf: pandas dataframe or None, optionally determine percentiles using another dataset. See second note.</span>
<span class="sd">    portvar: string, name of portfolio variable in the output dataset</span>
<span class="sd">    multiprocess: bool or int, set to True to use all available processors,</span>
<span class="sd">                  set to False to use only one, pass an int less or equal to than number of</span>
<span class="sd">                  processors to use that amount of processors</span>

<span class="sd">    NOTE: Resets index and drops in output data, so don&#39;t use if index is important (input data not affected)</span>
<span class="sd">    NOTE: If using a cutdf, MUST have the same bygroups as df. The number of observations within each bygroup</span>
<span class="sd">          can be different, but there MUST be a one-to-one match of bygroups, or this will NOT work correctly.</span>
<span class="sd">          This may require some cleaning of the cutdf first.</span>
<span class="sd">    NOTE: For some reason, multiprocessing seems to be slower in testing, so it is disabled by default</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check types</span>
    <span class="n">_check_portfolio_inputs</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">groupvar</span><span class="p">,</span>
        <span class="n">ngroups</span><span class="o">=</span><span class="n">ngroups</span><span class="p">,</span>
        <span class="n">byvars</span><span class="o">=</span><span class="n">byvars</span><span class="p">,</span>
        <span class="n">cutdf</span><span class="o">=</span><span class="n">cutdf</span><span class="p">,</span>
        <span class="n">portvar</span><span class="o">=</span><span class="n">portvar</span><span class="p">,</span>
        <span class="n">cutoffs</span><span class="o">=</span><span class="n">cutoffs</span><span class="p">,</span>
        <span class="n">quant_cutoffs</span><span class="o">=</span><span class="n">quant_cutoffs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">byvars</span> <span class="o">=</span> <span class="n">_assert_byvars_list</span><span class="p">(</span><span class="n">byvars</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutdf</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cutdf</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># this is where cutdf == None, the default case</span>
        <span class="n">cutdf</span> <span class="o">=</span> <span class="n">df</span>
        <span class="n">tempcutdf</span> <span class="o">=</span> <span class="n">cutdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># With passed cutoffs, can skip all logic to calculate cutoffs, and go right to portfolio sort</span>
    <span class="k">if</span> <span class="n">cutoffs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Must add a minimum and maximum to cutoffs (bottom of lowest port, top of highest port)</span>
        <span class="c1"># for code to work properly</span>
        <span class="n">min_groupvar_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">groupvar</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">max_groupvar_value</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">groupvar</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">all_cutoffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_groupvar_value</span><span class="p">]</span> <span class="o">+</span> <span class="n">cutoffs</span> <span class="o">+</span> <span class="p">[</span><span class="n">max_groupvar_value</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_sort_into_ports</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">all_cutoffs</span><span class="p">,</span> <span class="n">portvar</span><span class="p">,</span> <span class="n">groupvar</span><span class="p">)</span>

    <span class="c1"># Hard cutoffs not passed, handle percentile based portfolios (either ngroups or passed quant_cuts)</span>
    <span class="k">if</span> <span class="n">quant_cutoffs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Must add a minimum and maximum to quant cutoffs and scale to 0-100 for code to work properly</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">q</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quant_cutoffs</span><span class="p">],</span> <span class="mi">100</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ngroups handling</span>
        <span class="n">pct_per_group</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ngroups</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span> <span class="o">*</span> <span class="n">pct_per_group</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngroups</span><span class="p">)</span>
        <span class="p">]</span>  <span class="c1"># percentile values, e.g. 0, 10, 20, 30... 100</span>
        <span class="n">percentiles</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">100</span><span class="p">]</span>

    <span class="c1"># Create new functions with common arguments added. First function is for handling entire df, second is for</span>
    <span class="c1"># splitting into numpy arrays by byvars</span>
    <span class="n">create_cutoffs_if_necessary_and_sort_into_ports</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
        <span class="n">_create_cutoffs_and_sort_into_ports</span><span class="p">,</span>
        <span class="n">groupvar</span><span class="o">=</span><span class="n">groupvar</span><span class="p">,</span>
        <span class="n">portvar</span><span class="o">=</span><span class="n">portvar</span><span class="p">,</span>
        <span class="n">percentiles</span><span class="o">=</span><span class="n">percentiles</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">sort_arr_list_into_ports_and_return_series</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
        <span class="n">_sort_arr_list_into_ports_and_return_series</span><span class="p">,</span>
        <span class="n">percentiles</span><span class="o">=</span><span class="n">percentiles</span><span class="p">,</span>
        <span class="n">multiprocess</span><span class="o">=</span><span class="n">multiprocess</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">split</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_split</span><span class="p">,</span> <span class="n">keepvars</span><span class="o">=</span><span class="p">[</span><span class="n">groupvar</span><span class="p">],</span> <span class="n">force_numeric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">tempdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># If there are no byvars, just complete portfolio sort</span>
    <span class="k">if</span> <span class="n">byvars</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">create_cutoffs_if_necessary_and_sort_into_ports</span><span class="p">(</span><span class="n">tempdf</span><span class="p">,</span> <span class="n">cutdf</span><span class="p">)</span>

    <span class="c1"># The below rename is incase there is already a variable named index in the data</span>
    <span class="c1"># The rename will just not do anything if there&#39;s not</span>
    <span class="n">tempdf</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tempdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;__temp_index__&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="p">)</span>  <span class="c1"># get a variable &#39;index&#39; containing obs count</span>

    <span class="c1"># Also replace index in byvars if there</span>
    <span class="n">temp_byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="s2">&quot;index&quot;</span> <span class="k">else</span> <span class="s2">&quot;__temp_index__&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">byvars</span><span class="p">]</span>
    <span class="n">all_byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_byvars</span><span class="p">,</span> <span class="n">byvars</span><span class="p">]</span>  <span class="c1"># list of lists</span>

    <span class="c1"># else, deal with byvars</span>
    <span class="c1"># First create a key variable based on all the byvars</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_df</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">tempdf</span><span class="p">,</span> <span class="n">tempcutdf</span><span class="p">]):</span>
        <span class="n">this_df</span><span class="p">[</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;key&quot;</span>  <span class="c1"># container for key</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="n">this_df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_byvars</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
            <span class="n">this_df</span><span class="p">[</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">col</span>
        <span class="n">this_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Now split into list of arrays and process</span>
    <span class="n">array_list</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tempdf</span><span class="p">)</span>
    <span class="n">cut_array_list</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">tempcutdf</span><span class="p">)</span>

    <span class="n">tempdf</span> <span class="o">=</span> <span class="n">tempdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span>
        <span class="n">drop</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>  <span class="c1"># need to reset index again for adding new column</span>
    <span class="n">tempdf</span><span class="p">[</span><span class="n">portvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">sort_arr_list_into_ports_and_return_series</span><span class="p">(</span>
        <span class="n">array_list</span><span class="p">,</span> <span class="n">cut_array_list</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">tempdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;__key_var__&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;__temp_index__&quot;</span><span class="p">:</span> <span class="s2">&quot;index&quot;</span><span class="p">})</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="portfolio_averages"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.portfolio_averages">[docs]</a><span class="k">def</span> <span class="nf">portfolio_averages</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">groupvar</span><span class="p">,</span>
    <span class="n">avgvars</span><span class="p">,</span>
    <span class="n">ngroups</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">byvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cutdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wtvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">count</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">portvar</span><span class="o">=</span><span class="s2">&quot;portfolio&quot;</span><span class="p">,</span>
    <span class="n">avgonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates portfolios and calculates equal- and value-weighted averages of variables within portfolios. If ngroups=10,</span>
<span class="sd">    then will form 10 portfolios, with portfolio 1 having the bottom 10 percentile of groupvar, and portfolio 10 having</span>
<span class="sd">    the top 10 percentile of groupvar.</span>

<span class="sd">    df: pandas dataframe, input data</span>
<span class="sd">    groupvar: string, name of variable in df to form portfolios on</span>
<span class="sd">    avgvars: string or list, variables to be averaged</span>
<span class="sd">    ngroups: integer, number of portfolios to form</span>
<span class="sd">    byvars: string, list, or None, name of variable(s) in df, finds portfolios within byvars. For example if byvars=&#39;Month&#39;,</span>
<span class="sd">            would take each month and form portfolios based on the percentiles of the groupvar during only that month</span>
<span class="sd">    cutdf: pandas dataframe or None, optionally determine percentiles using another dataset</span>
<span class="sd">    wtvar: string, name of variable in df to use for weighting in weighted average</span>
<span class="sd">    count: False or string of variable name, pass variable name to get count of non-missing</span>
<span class="sd">           of that variable within groups.</span>
<span class="sd">    portvar: string, name of portfolio variable in the output dataset</span>
<span class="sd">    avgonly: boolean, True to return only averages, False to return (averages, individual observations with portfolios)</span>

<span class="sd">    NOTE: Resets index and drops in output data, so don&#39;t use if index is important (input data not affected)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ports</span> <span class="o">=</span> <span class="n">portfolio</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">groupvar</span><span class="p">,</span> <span class="n">ngroups</span><span class="o">=</span><span class="n">ngroups</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="n">byvars</span><span class="p">,</span> <span class="n">cutdf</span><span class="o">=</span><span class="n">cutdf</span><span class="p">,</span> <span class="n">portvar</span><span class="o">=</span><span class="n">portvar</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">byvars</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">byvars</span><span class="p">]</span>
        <span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">portvar</span><span class="p">]</span> <span class="o">+</span> <span class="n">byvars</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">averages</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="n">avgvars</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">wtvar</span><span class="o">=</span><span class="n">wtvar</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">averages</span><span class="p">(</span><span class="n">ports</span><span class="p">,</span> <span class="n">avgvars</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="n">portvar</span><span class="p">,</span> <span class="n">wtvar</span><span class="o">=</span><span class="n">wtvar</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">avgonly</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avgs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avgs</span><span class="p">,</span> <span class="n">ports</span></div>


<div class="viewcode-block" id="factor_reg_by"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.factor_reg_by">[docs]</a><span class="k">def</span> <span class="nf">factor_reg_by</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">groupvar</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">retvar</span><span class="o">=</span><span class="s2">&quot;RET&quot;</span><span class="p">,</span> <span class="n">mp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dataframe with RET, mktrf, smb, hml, and umd, and produces abnormal returns by groups.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas datafram containing mktrf, smb, hml, umd, (or what&#39;s required for chosen model)</span>
<span class="sd">        and a return variable</span>
<span class="sd">    groupvar: str or list of strs, column names of columns on which to form by groups</span>
<span class="sd">    fac: int (1, 3, 4), factor model to run</span>
<span class="sd">    retvar: str, name of column containing returns. risk free rate will be subtracted from this column</span>
<span class="sd">    stderr: bool, True to include standard errors of coefficients</span>

<span class="sd">    Optional Inputs:</span>
<span class="sd">    mp: False to use single processor, True to use all processors, int to use # processors</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">fac</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;mktrf&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fac</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">factors</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;smb&quot;</span><span class="p">,</span> <span class="s2">&quot;hml&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fac</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">factors</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;rmw&quot;</span><span class="p">,</span> <span class="s2">&quot;cma&quot;</span><span class="p">]</span>

    <span class="c1"># Create returns in excess of risk free rate</span>
    <span class="n">excess_var</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">retvar</span> <span class="o">+</span> <span class="s2">&quot;_minus_rf&quot;</span>
    <span class="n">df</span><span class="p">[</span><span class="n">excess_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">retvar</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;rf&quot;</span><span class="p">]</span>

    <span class="n">outdf</span> <span class="o">=</span> <span class="n">reg_by</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">excess_var</span><span class="p">,</span> <span class="n">factors</span><span class="p">,</span> <span class="n">groupvar</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mp</span><span class="o">=</span><span class="n">mp</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">stderr</span><span class="p">)</span>
    <span class="n">outdf</span><span class="p">[</span><span class="s2">&quot;AB&quot;</span> <span class="o">+</span> <span class="n">retvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">outdf</span><span class="p">[</span><span class="n">retvar</span><span class="p">]</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">outdf</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span> <span class="o">*</span> <span class="n">outdf</span><span class="p">[</span><span class="s2">&quot;coef_&quot;</span> <span class="o">+</span> <span class="n">fac</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># create abnormal returns</span>

    <span class="c1"># Cleanup excess returns</span>
    <span class="n">outdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">excess_var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">outdf</span></div>


<div class="viewcode-block" id="state_abbrev"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.state_abbrev">[docs]</a><span class="k">def</span> <span class="nf">state_abbrev</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">toabbrev</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">states_to_abbrev</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Alabama&quot;</span><span class="p">:</span> <span class="s2">&quot;AL&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Montana&quot;</span><span class="p">:</span> <span class="s2">&quot;MT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Alaska&quot;</span><span class="p">:</span> <span class="s2">&quot;AK&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Nebraska&quot;</span><span class="p">:</span> <span class="s2">&quot;NE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Arizona&quot;</span><span class="p">:</span> <span class="s2">&quot;AZ&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Nevada&quot;</span><span class="p">:</span> <span class="s2">&quot;NV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Arkansas&quot;</span><span class="p">:</span> <span class="s2">&quot;AR&quot;</span><span class="p">,</span>
        <span class="s2">&quot;New Hampshire&quot;</span><span class="p">:</span> <span class="s2">&quot;NH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;California&quot;</span><span class="p">:</span> <span class="s2">&quot;CA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;New Jersey&quot;</span><span class="p">:</span> <span class="s2">&quot;NJ&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Colorado&quot;</span><span class="p">:</span> <span class="s2">&quot;CO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;New Mexico&quot;</span><span class="p">:</span> <span class="s2">&quot;NM&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Connecticut&quot;</span><span class="p">:</span> <span class="s2">&quot;CT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;New York&quot;</span><span class="p">:</span> <span class="s2">&quot;NY&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Delaware&quot;</span><span class="p">:</span> <span class="s2">&quot;DE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;North Carolina&quot;</span><span class="p">:</span> <span class="s2">&quot;NC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Florida&quot;</span><span class="p">:</span> <span class="s2">&quot;FL&quot;</span><span class="p">,</span>
        <span class="s2">&quot;North Dakota&quot;</span><span class="p">:</span> <span class="s2">&quot;ND&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Georgia&quot;</span><span class="p">:</span> <span class="s2">&quot;GA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Ohio&quot;</span><span class="p">:</span> <span class="s2">&quot;OH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Hawaii&quot;</span><span class="p">:</span> <span class="s2">&quot;HI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Oklahoma&quot;</span><span class="p">:</span> <span class="s2">&quot;OK&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Idaho&quot;</span><span class="p">:</span> <span class="s2">&quot;ID&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Oregon&quot;</span><span class="p">:</span> <span class="s2">&quot;OR&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Illinois&quot;</span><span class="p">:</span> <span class="s2">&quot;IL&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Pennsylvania&quot;</span><span class="p">:</span> <span class="s2">&quot;PA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Indiana&quot;</span><span class="p">:</span> <span class="s2">&quot;IN&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Rhode Island&quot;</span><span class="p">:</span> <span class="s2">&quot;RI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Iowa&quot;</span><span class="p">:</span> <span class="s2">&quot;IA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;South Carolina&quot;</span><span class="p">:</span> <span class="s2">&quot;SC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Kansas&quot;</span><span class="p">:</span> <span class="s2">&quot;KS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;South Dakota&quot;</span><span class="p">:</span> <span class="s2">&quot;SD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Kentucky&quot;</span><span class="p">:</span> <span class="s2">&quot;KY&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Tennessee&quot;</span><span class="p">:</span> <span class="s2">&quot;TN&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Louisiana&quot;</span><span class="p">:</span> <span class="s2">&quot;LA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Texas&quot;</span><span class="p">:</span> <span class="s2">&quot;TX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Maine&quot;</span><span class="p">:</span> <span class="s2">&quot;ME&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Utah&quot;</span><span class="p">:</span> <span class="s2">&quot;UT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Maryland&quot;</span><span class="p">:</span> <span class="s2">&quot;MD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Vermont&quot;</span><span class="p">:</span> <span class="s2">&quot;VT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Massachusetts&quot;</span><span class="p">:</span> <span class="s2">&quot;MA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Virginia&quot;</span><span class="p">:</span> <span class="s2">&quot;VA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Michigan&quot;</span><span class="p">:</span> <span class="s2">&quot;MI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Washington&quot;</span><span class="p">:</span> <span class="s2">&quot;WA&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Minnesota&quot;</span><span class="p">:</span> <span class="s2">&quot;MN&quot;</span><span class="p">,</span>
        <span class="s2">&quot;West Virginia&quot;</span><span class="p">:</span> <span class="s2">&quot;WV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Mississippi&quot;</span><span class="p">:</span> <span class="s2">&quot;MS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Wisconsin&quot;</span><span class="p">:</span> <span class="s2">&quot;WI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Missouri&quot;</span><span class="p">:</span> <span class="s2">&quot;MO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Wyoming&quot;</span><span class="p">:</span> <span class="s2">&quot;WY&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">toabbrev</span><span class="p">:</span>
        <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">states_to_abbrev</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">abbrev_to_states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">states_to_abbrev</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">abbrev_to_states</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="USTradingCalendar"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.USTradingCalendar">[docs]</a><span class="k">class</span> <span class="nc">USTradingCalendar</span><span class="p">(</span><span class="n">AbstractHolidayCalendar</span><span class="p">):</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Holiday</span><span class="p">(</span><span class="s2">&quot;NewYearsDay&quot;</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">observance</span><span class="o">=</span><span class="n">nearest_workday</span><span class="p">),</span>
        <span class="n">USMartinLutherKingJr</span><span class="p">,</span>
        <span class="n">USPresidentsDay</span><span class="p">,</span>
        <span class="n">GoodFriday</span><span class="p">,</span>
        <span class="n">USMemorialDay</span><span class="p">,</span>
        <span class="n">Holiday</span><span class="p">(</span><span class="s2">&quot;USIndependenceDay&quot;</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">observance</span><span class="o">=</span><span class="n">nearest_workday</span><span class="p">),</span>
        <span class="n">USLaborDay</span><span class="p">,</span>
        <span class="n">USThanksgivingDay</span><span class="p">,</span>
        <span class="n">Holiday</span><span class="p">(</span><span class="s2">&quot;Christmas&quot;</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">observance</span><span class="o">=</span><span class="n">nearest_workday</span><span class="p">),</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="tradedays"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.tradedays">[docs]</a><span class="k">def</span> <span class="nf">tradedays</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used for constructing a range of dates with pandas date_range function.</span>

<span class="sd">    :Example:</span>

<span class="sd">    &gt;&gt;&gt;import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt;import pd_utils</span>
<span class="sd">    &gt;&gt;&gt;pd.date_range(</span>
<span class="sd">    &gt;&gt;&gt;    start=&#39;1/1/2000&#39;,</span>
<span class="sd">    &gt;&gt;&gt;    end=&#39;1/31/2000&#39;,</span>
<span class="sd">    &gt;&gt;&gt;    freq=pd_utils.tradedays()</span>
<span class="sd">    &gt;&gt;&gt;)</span>
<span class="sd">    pd.DatetimeIndex([&#39;2000-01-03&#39;, &#39;2000-01-04&#39;, &#39;2000-01-05&#39;, &#39;2000-01-06&#39;,</span>
<span class="sd">               &#39;2000-01-07&#39;, &#39;2000-01-10&#39;, &#39;2000-01-11&#39;, &#39;2000-01-12&#39;,</span>
<span class="sd">               &#39;2000-01-13&#39;, &#39;2000-01-14&#39;, &#39;2000-01-18&#39;, &#39;2000-01-19&#39;,</span>
<span class="sd">               &#39;2000-01-20&#39;, &#39;2000-01-21&#39;, &#39;2000-01-24&#39;, &#39;2000-01-25&#39;,</span>
<span class="sd">               &#39;2000-01-26&#39;, &#39;2000-01-27&#39;, &#39;2000-01-28&#39;, &#39;2000-01-31&#39;],</span>
<span class="sd">              dtype=&#39;datetime64[ns]&#39;, freq=&#39;C&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trading_calendar</span> <span class="o">=</span> <span class="n">USTradingCalendar</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">CustomBusinessDay</span><span class="p">(</span><span class="n">holidays</span><span class="o">=</span><span class="n">trading_calendar</span><span class="o">.</span><span class="n">holidays</span><span class="p">())</span></div>


<div class="viewcode-block" id="select_rows_by_condition_on_columns"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.select_rows_by_condition_on_columns">[docs]</a><span class="k">def</span> <span class="nf">select_rows_by_condition_on_columns</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;== 1&quot;</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="s2">&quot;or&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects rows of a pandas dataframe by evaluating a condition on a subset of the dataframe&#39;s columns.</span>

<span class="sd">    df: pandas dataframe</span>
<span class="sd">    cols: list of column names, the subset of columns on which to evaluate conditions</span>
<span class="sd">    condition: string, needs to contain comparison operator and right hand side of comparison. For example,</span>
<span class="sd">               &#39;== 1&#39; checks for each row that the value of each column is equal to one.</span>
<span class="sd">    logic: &#39;or&#39; or &#39;and&#39;. With &#39;or&#39;, only one of the columns in cols need to match the condition for the row to be kept.</span>
<span class="sd">            With &#39;and&#39;, all of the columns in cols need to match the condition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First eliminate spaces in columns, this method will not work with spaces</span>
    <span class="n">new_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]</span>
    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">new_col</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">new_cols</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Now create a string to query the dataframe with</span>
    <span class="n">logic_spaces</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">logic</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
    <span class="n">query_str</span> <span class="o">=</span> <span class="n">logic_spaces</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">+</span> <span class="n">condition</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">new_cols</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1">#&#39;col1 == 1, col2 == 1&#39;, etc.</span>

    <span class="c1"># Query dataframe</span>
    <span class="n">outdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_str</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Rename columns back to original</span>
    <span class="n">outdf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">new_col</span><span class="p">:</span> <span class="n">col</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">new_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">new_cols</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">outdf</span></div>


<div class="viewcode-block" id="show_df"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.show_df">[docs]</a><span class="k">def</span> <span class="nf">show_df</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">_show_df</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">])</span></div>


<span class="k">def</span> <span class="nf">_show_df</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">pandastable</span> <span class="kn">import</span> <span class="n">Table</span>
    <span class="kn">from</span> <span class="nn">tkinter</span> <span class="kn">import</span> <span class="n">Tk</span><span class="p">,</span> <span class="n">Frame</span><span class="p">,</span> <span class="n">BOTH</span><span class="p">,</span> <span class="n">YES</span>
    <span class="c1"># TODO [#2]: remove show_df or update imports</span>
    <span class="c1">#</span>
    <span class="c1"># this import was causing an issue importing pandas.tools with pandas 0.24.x, moved here as a temp fix</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">Tk</span><span class="p">()</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="n">frame</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="n">BOTH</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="n">YES</span><span class="p">)</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span> <span class="n">dataframe</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">queryBar</span><span class="p">()</span>
    <span class="n">root</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>


<div class="viewcode-block" id="groupby_merge"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.groupby_merge">[docs]</a><span class="k">def</span> <span class="nf">groupby_merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">func_str</span><span class="p">,</span> <span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a pandas groupby object, applies the aggregation function in func_str, and merges back the</span>
<span class="sd">    aggregated data to the original dataframe.</span>

<span class="sd">    Required Inputs:</span>
<span class="sd">    df: Pandas DataFrame</span>
<span class="sd">    byvars: str or list, column names which uniquely identify groups</span>
<span class="sd">    func_str: str, name of groupby aggregation function such as &#39;min&#39;, &#39;max&#39;, &#39;sum&#39;, &#39;count&#39;, etc.</span>

<span class="sd">    Optional Input:</span>
<span class="sd">    subset: str or list, column names for which to apply aggregation functions</span>
<span class="sd">    func_args: tuple, arguments to pass to func</span>
<span class="sd">    replace: bool, True to replace original columns in the data with aggregated/transformed columns</span>

<span class="sd">    Usage:</span>
<span class="sd">    df = groupby_merge(df, [&#39;PERMNO&#39;,&#39;byvar&#39;], &#39;max&#39;, subset=&#39;RET&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert byvars to list if neceessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">byvars</span><span class="p">]</span>

    <span class="c1"># Store all variables except byvar in subset if subset is &#39;all&#39;</span>
    <span class="k">if</span> <span class="n">subset</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">byvars</span><span class="p">]</span>

    <span class="c1"># Convert subset to list if necessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>

    <span class="c1"># Groupby expects to receive a string if there is a single variable</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">groupby_subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">groupby_subset</span> <span class="o">=</span> <span class="n">subset</span>

    <span class="k">if</span> <span class="n">func_str</span> <span class="o">==</span> <span class="s2">&quot;transform&quot;</span><span class="p">:</span>
        <span class="c1"># transform works very differently from other aggregation functions</span>

        <span class="c1"># First we need to deal with nans in the by variables. If there are any nans, transform will error out</span>
        <span class="c1"># Therefore we must fill the nans in the by variables beforehand and replace afterwards</span>
        <span class="n">df</span><span class="p">[</span><span class="n">byvars</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">byvars</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s2">&quot;__tempnan__&quot;</span><span class="p">)</span>

        <span class="c1"># Now we must deal with nans in the subset variables. If there are any nans, tranform will error out</span>
        <span class="c1"># because it tries to ignore the nan. Therefore we must remove these rows from the dataframe,</span>
        <span class="c1"># transform, then add those rows back.</span>
        <span class="n">any_nan_subset_mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">all</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">]))],</span>
            <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">no_nans</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">any_nan_subset_mask</span><span class="p">]</span>

        <span class="n">grouped</span> <span class="o">=</span> <span class="n">no_nans</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">byvars</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">grouped</span><span class="p">,</span> <span class="n">func_str</span>
        <span class="p">)</span>  <span class="c1"># pull method of groupby class with same name as func_str</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">)[</span>
            <span class="n">groupby_subset</span>
        <span class="p">]</span>  <span class="c1"># apply the class method and select subset columns</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">grouped</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">func_str</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">grouped</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">]</span>  <span class="c1"># rename transformed columns</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">grouped</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">grouped</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">func_str</span>

        <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__tempnan__&quot;</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># fill nan back into dataframe</span>

        <span class="c1"># Put nan rows back</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">grouped</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># .min(), .max(), etc.</span>

        <span class="c1">#         grouped = df.groupby(byvars, as_index=False)[byvars + subset]</span>
        <span class="c1">#         func = getattr(grouped, func_str) #pull method of groupby class with same name as func_str</span>
        <span class="c1">#         grouped = func(*func_args) #apply the class method</span>

        <span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">byvars</span><span class="p">)[</span><span class="n">groupby_subset</span><span class="p">]</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="n">grouped</span><span class="p">,</span> <span class="n">func_str</span>
        <span class="p">)</span>  <span class="c1"># pull method of groupby class with same name as func_str</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">)</span>  <span class="c1"># apply the class method</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># Merge and output</span>
        <span class="n">full</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">byvars</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">func_str</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
        <span class="n">_replace_with_transformed</span><span class="p">(</span><span class="n">full</span><span class="p">,</span> <span class="n">func_str</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">full</span></div>


<span class="k">def</span> <span class="nf">_replace_with_transformed</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">func_str</span><span class="o">=</span><span class="s2">&quot;transform&quot;</span><span class="p">):</span>
    <span class="n">transform_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">func_str</span><span class="p">)]</span>
    <span class="n">orig_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">[:</span> <span class="n">col</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">func_str</span><span class="p">)]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">transform_cols</span><span class="p">]</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">orig_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">old</span><span class="p">:</span> <span class="n">new</span> <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">transform_cols</span><span class="p">,</span> <span class="n">orig_names</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>


<div class="viewcode-block" id="groupby_index"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.groupby_index">[docs]</a><span class="k">def</span> <span class="nf">groupby_index</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">sortvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a dataframe which is a copy of the old one with an additional column containing an index</span>
<span class="sd">    by groups. Each time the bygroup changes, the index restarts at 0.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas DataFrame</span>
<span class="sd">    byvars: str or list of column names containing group identifiers</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    sortvars: str or list of column names to sort by within by groups</span>
<span class="sd">    ascending: bool, direction of sort</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert sortvars to list if necessary</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortvars</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">sortvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortvars</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sortvars</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sortvars</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># don&#39;t modify the original dataframe</span>
    <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">byvars</span> <span class="o">+</span> <span class="n">sortvars</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;__temp_cons__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">groupby_merge</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">byvars</span><span class="p">,</span>
        <span class="s2">&quot;transform&quot;</span><span class="p">,</span>
        <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]),</span>
        <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;__temp_cons__&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;__temp_cons__&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;__temp_cons___transform&quot;</span><span class="p">:</span> <span class="s2">&quot;group_index&quot;</span><span class="p">})</span></div>


<div class="viewcode-block" id="to_copy_paste"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.to_copy_paste">[docs]</a><span class="k">def</span> <span class="nf">to_copy_paste</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dataframe and prints all of its data in such a format that it can be copy-pasted to create</span>
<span class="sd">    a new dataframe from the pandas.DataFrame() constructor.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas dataframe</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    index: bool, True to include index</span>
<span class="sd">    column_names: bool, False to exclude column names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pd.DataFrame(data = [&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">last_line</span> <span class="o">=</span> <span class="s2">&quot;]&quot;</span>
    <span class="k">if</span> <span class="n">column_names</span><span class="p">:</span>
        <span class="n">last_line</span> <span class="o">+=</span> <span class="s2">&quot;, columns = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># list comp to remove Index() around cols</span>
    <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
        <span class="n">last_line</span> <span class="o">+=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> index = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># list comp to remove Index() around index</span>
    <span class="n">last_line</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>  <span class="c1"># end command</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">last_line</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_join_col_strings</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">strs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>


<div class="viewcode-block" id="join_col_strings"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.join_col_strings">[docs]</a><span class="k">def</span> <span class="nf">join_col_strings</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dataframe and column name(s) and concatenates string versions of the columns with those names.</span>
<span class="sd">    Useful for when a group is identified by several variables and we need one key variable to describe a group.</span>
<span class="sd">    Returns a pandas Series.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas dataframe</span>
<span class="sd">    cols: str or list, names of columns in df to be concatenated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">cols</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="n">jc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_join_col_strings</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">jc</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">]))</span></div>


<div class="viewcode-block" id="winsorize"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.winsorize">[docs]</a><span class="k">def</span> <span class="nf">winsorize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pct</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds observations above the pct percentile and replaces the with the pct percentile value.</span>
<span class="sd">    Does this for all columns, or the subset given by subset</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: Pandas dataframe</span>
<span class="sd">    pct: 0 &lt; float &lt; 1 or list of two values 0 &lt; float &lt; 1. If two values are given, the first</span>
<span class="sd">         will be used for the bottom percentile and the second will be used for the top. If one value</span>
<span class="sd">         is given and both bot and top are True, will use the same value for both.</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    subset: List of strings or string of column name(s) to winsorize</span>
<span class="sd">    byvars: str, list of strs, or None. Column names of columns identifying groups in the data.</span>
<span class="sd">            Winsorizing will be done within those groups.</span>
<span class="sd">    bot: bool, True to winsorize bottom observations</span>
<span class="sd">    top: bool, True to winsorize top observations</span>

<span class="sd">    Example usage:</span>
<span class="sd">    winsorize(df, .05, subset=&#39;RET&#39;) #replaces observations of RET below the 5% and above the 95% values</span>
<span class="sd">    winsorize(df, [.05, .1], subset=&#39;RET&#39;) #replaces observations of RET below the 5% and above the 90% values</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check inputs</span>
    <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">])</span>  <span class="c1"># must winsorize something</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pct</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">bot_pct</span> <span class="o">=</span> <span class="n">pct</span>
        <span class="n">top_pct</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pct</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">bot_pct</span> <span class="o">=</span> <span class="n">pct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">top_pct</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">pct</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pct must be float or a list of two floats&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">temp_winsor</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_winsorize</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">top_pct</span><span class="p">,</span> <span class="n">bot_pct</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="p">,</span> <span class="n">bot</span><span class="o">=</span><span class="n">bot</span><span class="p">)</span>

    <span class="c1"># Save column order</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>

    <span class="c1"># Get a dataframe of data to be winsorized, and a dataframe of the other columns</span>
    <span class="n">to_winsor</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">_select_numeric_or_subset</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">extra_include</span><span class="o">=</span><span class="n">byvars</span><span class="p">)</span>

    <span class="c1"># Now winsorize</span>
    <span class="k">if</span> <span class="n">byvars</span><span class="p">:</span>  <span class="c1"># use groupby to process groups individually</span>
        <span class="n">to_winsor</span> <span class="o">=</span> <span class="n">groupby_merge</span><span class="p">(</span>
            <span class="n">to_winsor</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">temp_winsor</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># do entire df, one column at a time</span>
        <span class="n">to_winsor</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">temp_winsor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">to_winsor</span><span class="p">,</span> <span class="n">rest</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="n">cols</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_winsorize</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">top_pct</span><span class="p">,</span> <span class="n">bot_pct</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Winsorizes a pandas Series</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">top</span><span class="p">:</span>
        <span class="n">top_val</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">top_pct</span><span class="p">)</span>
        <span class="n">col</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">col</span> <span class="o">&gt;</span> <span class="n">top_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_val</span>
    <span class="k">if</span> <span class="n">bot</span><span class="p">:</span>
        <span class="n">bot_val</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">bot_pct</span><span class="p">)</span>
        <span class="n">col</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">bot_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">bot_val</span>
    <span class="k">return</span> <span class="n">col</span>


<span class="k">def</span> <span class="nf">_select_numeric_or_subset</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">subset</span><span class="p">,</span> <span class="n">extra_include</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If subset is not None, selects all numeric columns. Else selects subset.</span>
<span class="sd">    If extra_include is not None and subset is None, will select all numeric columns plus</span>
<span class="sd">    those in extra_include.</span>
<span class="sd">    Returns a tuple of (dataframe containing subset columns, dataframe of other columns)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">subset</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">to_winsor</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">to_winsor</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="n">to_winsor</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">other_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">]</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">other_cols</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">extra_include</span><span class="p">:</span>
        <span class="n">to_winsor</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">to_winsor</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">extra_include</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rest</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">extra_include</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">to_winsor</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>


<div class="viewcode-block" id="apply_func_to_unique_and_merge"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.apply_func_to_unique_and_merge">[docs]</a><span class="k">def</span> <span class="nf">apply_func_to_unique_and_merge</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Many Pandas functions can be slow because they&#39;re doing repeated work. This function reduces</span>
<span class="sd">    the given series down to unique values, applies the function, then expands back up to the</span>
<span class="sd">    original shape of the data. Returns a series.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    seres: pd.Series</span>
<span class="sd">    func: function to be applied to the series.</span>

<span class="sd">    :Usage:</span>

<span class="sd">    &gt;&gt;&gt;import functools</span>
<span class="sd">    &gt;&gt;&gt;to_datetime = functools.partial(pd.to_datetime, format=&#39;%Y%m&#39;)</span>
<span class="sd">    &gt;&gt;&gt;apply_func_to_unique_and_merge(df[&#39;MONTH&#39;], to_datetime)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">unique</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">for_merge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">unique</span><span class="p">,</span> <span class="n">new</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">for_merge</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>  <span class="c1"># names of new columns</span>
    <span class="n">for_merge</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_cols</span>

    <span class="n">orig_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="n">orig_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">for_merge</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">orig_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">num_cols</span><span class="p">]</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_map_windows</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;between&quot;</span><span class="p">,</span> <span class="n">periodvar</span><span class="o">=</span><span class="s2">&quot;Shift Date&quot;</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;PERMNO&quot;</span><span class="p">,</span> <span class="s2">&quot;Date&quot;</span><span class="p">]</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the dataframe with an additional column __map_window__ containing the index of the window</span>
<span class="sd">    in which the observation resides. For example, if the windows are</span>
<span class="sd">    [[1],[2,3]], and the periods are 1/1/2000, 1/2/2000, 1/3/2000 for PERMNO 10516 with byvar</span>
<span class="sd">    &#39;a&#39;, the df rows would be as follows:</span>
<span class="sd">         (10516, &#39;a&#39;, &#39;1/1/2000&#39;, 0),</span>
<span class="sd">         (10516, &#39;a&#39;, &#39;1/2/2000&#39;, 1),</span>
<span class="sd">         (10516, &#39;a&#39;, &#39;1/3/2000&#39;, 1),</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># don&#39;t overwrite original dataframe</span>

    <span class="n">wm</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">window_mapping</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">groupby_merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">wm</span><span class="p">),</span> <span class="n">subset</span><span class="o">=</span><span class="n">periodvar</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">periodvar</span> <span class="o">+</span> <span class="s2">&quot;_transform&quot;</span><span class="p">:</span> <span class="s2">&quot;__map_window__&quot;</span><span class="p">})</span>


<div class="viewcode-block" id="left_merge_latest"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.left_merge_latest">[docs]</a><span class="k">def</span> <span class="nf">left_merge_latest</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">df2</span><span class="p">,</span>
    <span class="n">on</span><span class="p">,</span>
    <span class="n">left_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
    <span class="n">right_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
    <span class="n">max_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">,</span>
    <span class="n">low_memory</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Left merges df2 to df using on, but grabbing the most recent observation (right_datevar will be</span>
<span class="sd">    the soonest earlier than left_datevar). Useful for situations where data needs to be merged with</span>
<span class="sd">    mismatched dates, and just the most recent data available is needed.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: Pandas dataframe containing source data (all rows will be kept), must have on variables</span>
<span class="sd">        and left_datevar</span>
<span class="sd">    df2: Pandas dataframe containing data to be merged (only the most recent rows before source</span>
<span class="sd">        data will be kept)</span>
<span class="sd">    on: str or list of strs, names of columns on which to match, excluding date</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    left_datevar: str, name of date variable on which to merge in df</span>
<span class="sd">    right_datevar: str, name of date variable on which to merge in df2</span>
<span class="sd">    max_offset: int or datetime.timedelta, maximum amount of time to go back to look for a match.</span>
<span class="sd">        When datevar is a datetime column, pass datetime.timedelta. When datevar is an int column</span>
<span class="sd">        (e.g. year), pass an int. Currently only applicable for backend &#39;pandas&#39;</span>
<span class="sd">    backend: str, &#39;pandas&#39; or &#39;sql&#39;. Specify the underlying machinery used to perform the merge.</span>
<span class="sd">             &#39;pandas&#39; means native pandas, while &#39;sql&#39; uses pandasql. Try &#39;sql&#39; if you run</span>
<span class="sd">             out of memory.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="n">on</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">backend</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="s2">&quot;pd&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">low_memory</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_left_merge_latest_pandas_low_memory</span><span class="p">(</span>
                <span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">left_datevar</span><span class="o">=</span><span class="n">left_datevar</span><span class="p">,</span> <span class="n">right_datevar</span><span class="o">=</span><span class="n">right_datevar</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_left_merge_latest_pandas</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">df2</span><span class="p">,</span>
            <span class="n">on</span><span class="p">,</span>
            <span class="n">left_datevar</span><span class="o">=</span><span class="n">left_datevar</span><span class="p">,</span>
            <span class="n">right_datevar</span><span class="o">=</span><span class="n">right_datevar</span><span class="p">,</span>
            <span class="n">max_offset</span><span class="o">=</span><span class="n">max_offset</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">backend</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;sql&quot;</span><span class="p">,</span> <span class="s2">&quot;pandasql&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">max_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot yet handle max_offset for sql backend&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_left_merge_latest_sql</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">left_datevar</span><span class="o">=</span><span class="n">left_datevar</span><span class="p">,</span> <span class="n">right_datevar</span><span class="o">=</span><span class="n">right_datevar</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;select backend=&#39;pandas&#39; or backend=&#39;sql&#39;.&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_left_merge_latest_pandas</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">left_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">right_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">max_offset</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="n">many</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">left_datevar</span><span class="p">]]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="n">rename</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># if they are named the same, pandas will automatically add _x and _y to names</span>
    <span class="k">if</span> <span class="n">left_datevar</span> <span class="o">==</span> <span class="n">right_datevar</span><span class="p">:</span>
        <span class="n">rename</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># will need to rename the _x datevar for the last step</span>
        <span class="n">orig_left_datevar</span> <span class="o">=</span> <span class="n">left_datevar</span>
        <span class="n">left_datevar</span> <span class="o">+=</span> <span class="s2">&quot;_x&quot;</span>
        <span class="n">right_datevar</span> <span class="o">+=</span> <span class="s2">&quot;_y&quot;</span>

    <span class="n">lt</span> <span class="o">=</span> <span class="n">many</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">many</span><span class="p">[</span><span class="n">left_datevar</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">many</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span>
    <span class="p">]</span>  <span class="c1"># left with datadates less than date</span>

    <span class="k">if</span> <span class="n">max_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lt</span> <span class="o">=</span> <span class="n">lt</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">lt</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lt</span><span class="p">[</span><span class="n">left_datevar</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_offset</span><span class="p">]</span>

    <span class="c1"># find rows within groups which have the maximum right_datevar (soonest before left_datevar)</span>
    <span class="n">data_rows</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">lt</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">left_datevar</span><span class="p">])[</span><span class="n">right_datevar</span><span class="p">]</span>
        <span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lt</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">left_datevar</span><span class="p">,</span> <span class="n">right_datevar</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>  <span class="c1"># remove the _x for final merge</span>
        <span class="n">data_rows</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">left_datevar</span><span class="p">:</span> <span class="n">orig_left_datevar</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">datevar_for_merge</span> <span class="o">=</span> <span class="n">orig_left_datevar</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">datevar_for_merge</span> <span class="o">=</span> <span class="n">left_datevar</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data_rows</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">datevar_for_merge</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="c1"># for some reason is getting converted to object type</span>
    <span class="n">merged</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">merged</span>


<span class="k">def</span> <span class="nf">_left_merge_latest_pandas_low_memory</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">df2</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">on</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">left_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
    <span class="n">right_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span>
<span class="p">):</span>

    <span class="n">MERGE_DATE</span> <span class="o">=</span> <span class="s2">&quot;_merge_date&quot;</span>

    <span class="k">def</span> <span class="nf">_get_latest_date</span><span class="p">(</span><span class="n">orig_date</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last_date</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">date</span> <span class="o">&gt;</span> <span class="n">orig_date</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">last_date</span>
            <span class="n">last_date</span> <span class="o">=</span> <span class="n">date</span>
        <span class="c1"># Did not find any dates greater than passed date</span>
        <span class="n">last_date</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last_date</span> <span class="o">&lt;</span> <span class="n">orig_date</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">last_date</span>

    <span class="k">def</span> <span class="nf">_to_datetime</span><span class="p">(</span><span class="n">date_like</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skips converting NaT and NaN but does convert dates</span>
<span class="sd">        Args:</span>
<span class="sd">            date_like:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">date_like</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">date_like</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_like</span><span class="p">)</span>

    <span class="c1"># Need to handle conversion to datetime for created match date if originally a datetime type</span>
    <span class="n">date_is_datetime_type</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">left_datevar</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">])</span><span class="o">.</span><span class="n">columns</span>
    <span class="p">)</span>

    <span class="n">dfs_for_concat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df2_for_slice</span> <span class="o">=</span> <span class="n">df2</span><span class="p">[</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">right_datevar</span><span class="p">]]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
    <span class="n">num_grouped</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Starting low memory handling for left_merge_latest. Processing groups one at a time.</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">group_on</span><span class="p">,</span> <span class="n">group_df</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df2_group_df</span> <span class="o">=</span> <span class="n">df2_for_slice</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">group_on</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Did not find this obs in the second df, cannot get date to merge</span>
            <span class="n">group_df</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">dfs_for_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_df</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df2_group_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="c1"># Only got a single row for group df, so got a single date, wrap in a list</span>
            <span class="n">df2_dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">df2_group_df</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df2_dates</span> <span class="o">=</span> <span class="n">df2_group_df</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">df2_dates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">get_latest_date</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_get_latest_date</span><span class="p">,</span> <span class="n">dates</span><span class="o">=</span><span class="n">df2_dates</span><span class="p">)</span>
        <span class="n">group_df</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_df</span><span class="p">[</span><span class="n">left_datevar</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_latest_date</span><span class="p">)</span>
        <span class="n">dfs_for_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_df</span><span class="p">)</span>
        <span class="n">estimate_time</span><span class="p">(</span><span class="n">num_grouped</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">start_time</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Finished processing groups to get latest date. Now doing final merge.&quot;</span><span class="p">)</span>

    <span class="n">df_for_merge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs_for_concat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">dfs_for_concat</span>  <span class="c1"># free up memory</span>

    <span class="k">if</span> <span class="n">date_is_datetime_type</span><span class="p">:</span>
        <span class="n">df_for_merge</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_for_merge</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">_to_datetime</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle other type conversions</span>
        <span class="n">desired_dtype</span> <span class="o">=</span> <span class="n">df_for_merge</span><span class="p">[</span><span class="n">left_datevar</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">df_for_merge</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_for_merge</span><span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">desired_dtype</span><span class="p">)</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="n">df_for_merge</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
        <span class="n">df2</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">MERGE_DATE</span><span class="p">],</span> <span class="n">right_on</span><span class="o">=</span><span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">merged</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">MERGE_DATE</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">rename</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># if they are named the same, pandas will automatically add _x and _y to names</span>
    <span class="k">if</span> <span class="n">left_datevar</span> <span class="o">==</span> <span class="n">right_datevar</span><span class="p">:</span>
        <span class="n">rename</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># will need to rename the _x datevar for the last step</span>
        <span class="n">orig_left_datevar</span> <span class="o">=</span> <span class="n">left_datevar</span>
        <span class="n">left_datevar</span> <span class="o">+=</span> <span class="s2">&quot;_x&quot;</span>
        <span class="n">right_datevar</span> <span class="o">+=</span> <span class="s2">&quot;_y&quot;</span>

    <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>  <span class="c1"># remove the _x</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">left_datevar</span><span class="p">:</span> <span class="n">orig_left_datevar</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged</span>


<span class="k">def</span> <span class="nf">_left_merge_latest_sql</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">left_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">right_datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">left_datevar</span> <span class="o">==</span> <span class="n">right_datevar</span><span class="p">:</span>
        <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df2</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">right_datevar</span><span class="p">:</span> <span class="n">right_datevar</span> <span class="o">+</span> <span class="s2">&quot;_y&quot;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">right_datevar</span> <span class="o">+=</span> <span class="s2">&quot;_y&quot;</span>

    <span class="c1"># Pandasql cannot handle spaces in names, replace</span>
    <span class="n">df_reverse_col_replacements</span> <span class="o">=</span> <span class="n">_replace_df_columns_char</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">find_str</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">replace_str</span><span class="o">=</span><span class="s2">&quot;_&quot;</span>
    <span class="p">)</span>
    <span class="n">df2_reverse_col_replacements</span> <span class="o">=</span> <span class="n">_replace_df_columns_char</span><span class="p">(</span>
        <span class="n">df2</span><span class="p">,</span> <span class="n">find_str</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">replace_str</span><span class="o">=</span><span class="s2">&quot;_&quot;</span>
    <span class="p">)</span>
    <span class="n">orig_on</span> <span class="o">=</span> <span class="n">on</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">on</span><span class="p">]</span>

    <span class="n">on_str</span> <span class="o">=</span> <span class="s2">&quot; and </span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;a.</span><span class="si">{0}</span><span class="s2"> = b.</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">on</span><span class="p">])</span>
    <span class="n">groupby_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">on</span><span class="p">)</span>
    <span class="n">a_cols</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;a.&quot;</span> <span class="o">+</span> <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">on</span> <span class="o">+</span> <span class="p">[</span><span class="n">left_datevar</span><span class="p">]])</span>
    <span class="n">b_cols</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;b.&quot;</span> <span class="o">+</span> <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df2</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">on</span><span class="p">])</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    select </span><span class="si">{5}</span><span class="s2">, </span><span class="si">{4}</span><span class="s2"></span>
<span class="s2">    from</span>
<span class="s2">        df a</span>
<span class="s2">    left join</span>
<span class="s2">        df2 b</span>
<span class="s2">    on</span>
<span class="s2">        </span><span class="si">{0}</span><span class="s2"> and</span>
<span class="s2">        a.</span><span class="si">{1}</span><span class="s2"> &gt;= b.</span><span class="si">{2}</span><span class="s2"></span>
<span class="s2">    group by a.</span><span class="si">{3}</span><span class="s2">, a.</span><span class="si">{1}</span><span class="s2"></span>
<span class="s2">    having</span>
<span class="s2">        b.</span><span class="si">{2}</span><span class="s2"> = max(b.</span><span class="si">{2}</span><span class="s2">)</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">on_str</span><span class="p">,</span> <span class="n">left_datevar</span><span class="p">,</span> <span class="n">right_datevar</span><span class="p">,</span> <span class="n">groupby_str</span><span class="p">,</span> <span class="n">b_cols</span><span class="p">,</span> <span class="n">a_cols</span>
    <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">sql</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">df2</span><span class="p">],</span> <span class="n">query</span><span class="p">)</span>

    <span class="c1"># Reverse the name replacements, bring spaces back</span>
    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_reverse_col_replacements</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df2</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df2_reverse_col_replacements</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Get all replacements, for result table which may have columns from both</span>
    <span class="n">df_reverse_col_replacements</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">df2_reverse_col_replacements</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">df_reverse_col_replacements</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">orig_on</span> <span class="o">+</span> <span class="p">[</span><span class="n">left_datevar</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="c1"># for some reason is getting converted to object type</span>
    <span class="n">merged</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="n">right_datevar</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">merged</span>


<span class="k">def</span> <span class="nf">_replace_df_columns_char</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">find_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">replace_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Note: inplace</span>

<span class="sd">    Args:</span>
<span class="sd">        df:</span>
<span class="sd">        find_str:</span>
<span class="sd">        replace_str:</span>

<span class="sd">    Returns: reverse replacement dict, use to reverse changes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">replace_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">replace_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">find_str</span><span class="p">,</span> <span class="n">replace_str</span><span class="p">)</span>

    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">replace_dict</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">reverse_replace_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">replace_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">reverse_replace_dict</span>


<div class="viewcode-block" id="var_change_by_groups"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.var_change_by_groups">[docs]</a><span class="k">def</span> <span class="nf">var_change_by_groups</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">datevar</span><span class="o">=</span><span class="s2">&quot;Date&quot;</span><span class="p">,</span> <span class="n">numlags</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used for getting variable changes over time within bygroups.</span>

<span class="sd">    NOTE: Dataset is not sorted in this process. Sort the data in the order in which you wish</span>
<span class="sd">          lags to be created before running this command.</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas dataframe containing bygroups, a date variable, and variables of interest</span>
<span class="sd">    var: str or list of strs, column names of variables to get changes</span>
<span class="sd">    byvars: str or list of strs, column names of variables identifying by groups</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    datevar: str ot list of strs, column names of variables identifying periods</span>
<span class="sd">    numlags: int, number of periods to go back to get change</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">datevar</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_to_list_if_str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">var</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">datevar</span><span class="p">]</span>
    <span class="p">]</span>  <span class="c1"># convert to lists</span>
    <span class="n">short_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">byvars</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">var</span> <span class="o">+</span> <span class="n">byvars</span> <span class="o">+</span> <span class="n">datevar</span>
    <span class="p">]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var</span><span class="p">:</span>
        <span class="n">short_df</span><span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">short_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">byvars</span><span class="p">)[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">numlags</span><span class="p">)</span>
        <span class="n">short_df</span><span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;_change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">short_df</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-</span> <span class="n">short_df</span><span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span><span class="p">]</span>
    <span class="n">dropvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">var</span><span class="p">]</span>
    <span class="n">short_df</span> <span class="o">=</span> <span class="n">short_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">dropvars</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">short_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">datevar</span> <span class="o">+</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="fill_excluded_rows"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.fill_excluded_rows">[docs]</a><span class="k">def</span> <span class="nf">fill_excluded_rows</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">byvars</span><span class="p">,</span> <span class="n">fillvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fillna_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dataframe which does not contain all possible combinations of byvars as rows. Creates</span>
<span class="sd">    those rows if fillna_kwargs are passed, calls fillna using fillna_kwargs for fillvars.</span>

<span class="sd">    For example, df:</span>
<span class="sd">                 date     id  var</span>
<span class="sd">        0  2003-06-09 42223C    1</span>
<span class="sd">        1  2003-06-10 09255G    2</span>
<span class="sd">    with fillna_for_excluded_rows(df, byvars=[&#39;date&#39;,&#39;id&#39;], fillvars=&#39;var&#39;, value=0) becomes:</span>
<span class="sd">                  date     id  var</span>
<span class="sd">        0  2003-06-09 42223C    1</span>
<span class="sd">        1  2003-06-10 42223C    0</span>
<span class="sd">        2  2003-06-09 09255G    0</span>
<span class="sd">        3  2003-06-10 09255G    2</span>

<span class="sd">    Required options:</span>
<span class="sd">    df: pandas dataframe</span>
<span class="sd">    byvars: variables on which dataset should be expanded to product. Can pass a str, list of</span>
<span class="sd">            strs, or a list of pd.Series.</span>

<span class="sd">    Optional options:</span>
<span class="sd">    fillvars: variables to apply fillna to</span>
<span class="sd">    fillna_kwargs: See pandas.DataFrame.fillna for kwargs, value=0 is common</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">byvars</span><span class="p">,</span> <span class="n">fillvars</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_to_list_if_str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">byvars</span><span class="p">,</span> <span class="n">fillvars</span><span class="p">]</span>
    <span class="p">]</span>  <span class="c1"># convert to lists</span>

    <span class="c1">#     multiindex = [df[i].dropna().unique() for i in byvars]</span>
    <span class="n">multiindex</span> <span class="o">=</span> <span class="p">[</span><span class="n">_to_series_if_str</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">byvars</span><span class="p">]</span>
    <span class="n">byvars</span> <span class="o">=</span> <span class="p">[</span><span class="n">_to_name_if_series</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">byvars</span><span class="p">]</span>  <span class="c1"># get name of any series</span>

    <span class="n">all_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">(</span><span class="n">multiindex</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">all_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">byvars</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">byvars</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fillna_kwargs</span><span class="p">:</span>
        <span class="n">fillna_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
        <span class="n">merged</span><span class="p">[</span><span class="n">fillvars</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="n">fillvars</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">**</span><span class="n">fillna_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merged</span></div>


<div class="viewcode-block" id="sql"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.sql">[docs]</a><span class="k">def</span> <span class="nf">sql</span><span class="p">(</span><span class="n">df_list</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience function for running a pandasql query. Keeps track of which variables are of</span>
<span class="sd">    datetime type, and converts them back after running the sql query.</span>

<span class="sd">    NOTE: Ensure that dfs are passed in the order that they are used in the query.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Pandasql looks up tables by names given in query. Here we are passed a list of dfs without names.</span>
    <span class="c1"># Therefore we need to extract the names of the tables from the query, then assign</span>
    <span class="c1"># those names to the dfs in df_list in the locals dictionary.</span>
    <span class="n">table_names</span> <span class="o">=</span> <span class="n">_extract_table_names_from_sql</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table_names</span><span class="p">):</span>
        <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">df_list</span><span class="p">[</span><span class="n">i</span><span class="p">]})</span>

    <span class="c1"># Get date variable column names</span>
    <span class="n">datevars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#     othervars = []</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">:</span>
        <span class="n">datevars</span> <span class="o">+=</span> <span class="n">_get_datetime_cols</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="c1">#         othervars += [col for col in d.columns if col not in datevars]</span>
    <span class="n">datevars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">datevars</span><span class="p">))</span>  <span class="c1"># remove duplicates</span>
    <span class="c1">#     othervars = list(set(othervars))</span>

    <span class="n">merged</span> <span class="o">=</span> <span class="n">PandaSQL</span><span class="p">()(</span><span class="n">query</span><span class="p">)</span>

    <span class="c1"># Convert back to datetime</span>
    <span class="k">for</span> <span class="n">date</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">datevars</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">columns</span><span class="p">]:</span>
        <span class="n">merged</span><span class="p">[</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="n">date</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">merged</span></div>


<div class="viewcode-block" id="long_short_portfolio"><a class="viewcode-back" href="../api/pd_utils.html#pd_utils.long_short_portfolio">[docs]</a><span class="k">def</span> <span class="nf">long_short_portfolio</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">portvar</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retvars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">top_minus_bot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a df with a column of numbered portfolios and creates a new</span>
<span class="sd">    portfolio which is long the top portfolio and short the bottom portfolio.</span>
<span class="sd">    Returns a df of long-short portfolio</span>

<span class="sd">    Required inputs:</span>
<span class="sd">    df: pandas dataframe containing a column with portfolio numbers</span>
<span class="sd">    portvar: str, name of column containing portfolios</span>

<span class="sd">    Optional inputs:</span>
<span class="sd">    byvars: str or list of strs of column names containing groups for portfolios.</span>
<span class="sd">            Calculates long-short within these groups. These should be the same groups</span>
<span class="sd">            in which portfolios were formed.</span>
<span class="sd">    retvars: str or list of strs of variables to return in the long-short dataset.</span>
<span class="sd">            By default, will use all numeric variables in the df.</span>
<span class="sd">    top_minus_bot: boolean, True to be long the top portfolio, short the bottom portfolio.</span>
<span class="sd">                   False to be long the bottom portfolio, short the top portfolio.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">long</span><span class="p">,</span> <span class="n">short</span> <span class="o">=</span> <span class="n">_select_long_short_ports</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">portvar</span><span class="p">,</span> <span class="n">top_minus_bot</span><span class="o">=</span><span class="n">top_minus_bot</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_portfolio_difference</span><span class="p">(</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">portvar</span><span class="p">,</span> <span class="n">long</span><span class="p">,</span> <span class="n">short</span><span class="p">,</span> <span class="n">byvars</span><span class="o">=</span><span class="n">byvars</span><span class="p">,</span> <span class="n">retvars</span><span class="o">=</span><span class="n">retvars</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Nick DeRobertis

    </p>
  </div>
    
    
      Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-156908023-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>